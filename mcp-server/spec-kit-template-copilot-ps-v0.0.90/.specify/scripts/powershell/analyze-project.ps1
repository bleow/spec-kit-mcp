#!/usr/bin/env pwsh

#
# analyze-project.ps1 - AI-driven project analysis and modernization
#
# Usage:
#   ./analyze-project.ps1 PATH [-Output DIR]
#   ./analyze-project.ps1 -Project PATH [-Output DIR]
#
# This script enumerates a legacy project and prepares it for AI analysis.
# The AI agent will handle technology detection, file selection, and analysis.
#

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false, Position=0)]
    [string]$Project = ".",

    [Parameter(Mandatory=$false)]
    [string]$Output = "",

    [Parameter(Mandatory=$false)]
    [string]$Context = "",

    [Parameter(Mandatory=$false)]
    [ValidateSet("A", "B", "")]
    [string]$Scope = "",

    [Parameter(Mandatory=$false)]
    [string]$ConcernType = "",

    [Parameter(Mandatory=$false)]
    [string]$CurrentImpl = "",

    [Parameter(Mandatory=$false)]
    [string]$TargetImpl = "",

    [switch]$Help
)

$ErrorActionPreference = 'Stop'

# Auto-detect OS and redirect if needed
. "$PSScriptRoot/common.ps1"

$OS = Get-DetectedOS
if ($OS -eq "unix") {
    # Running PowerShell on Unix - redirect to bash
    $bashScript = Join-Path $PSScriptRoot "../bash/analyze-project.sh"

    # Forward all arguments to bash
    $bashArgs = @()
    if ($Project -and $Project -ne ".") { $bashArgs += $Project }
    if ($Output) { $bashArgs += "--output"; $bashArgs += $Output }
    if ($Context) { $bashArgs += "--context"; $bashArgs += $Context }
    if ($Scope) { $bashArgs += "--scope"; $bashArgs += $Scope }
    if ($ConcernType) { $bashArgs += "--concern-type"; $bashArgs += $ConcernType }
    if ($CurrentImpl) { $bashArgs += "--current-impl"; $bashArgs += $CurrentImpl }
    if ($TargetImpl) { $bashArgs += "--target-impl"; $bashArgs += $TargetImpl }
    if ($Help) { $bashArgs += "--help" }

    & bash $bashScript @bashArgs
    exit $LASTEXITCODE
}

# Continue with PowerShell implementation for Windows

# Script directory
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$repoRoot = Get-RepoRoot

# Show help if requested
if ($Help) {
    Write-Output "Usage: $($MyInvocation.MyCommand.Name) PATH [-Output DIR]"
    Write-Output "       $($MyInvocation.MyCommand.Name) -Project PATH [-Output DIR]"
    Write-Output ""
    Write-Output "AI-driven analysis of legacy projects for reverse engineering and modernization."
    Write-Output ""
    Write-Output "Parameters:"
    Write-Output "  PATH (positional)    Path to project root directory (default: current directory)"
    Write-Output "  -Project PATH        Named parameter for project path"
    Write-Output "  -Output DIR         Output directory (default: .analysis/PROJECT_NAME-TIMESTAMP)"
    Write-Output "  -Help               Show this help message"
    Write-Output ""
    Write-Output "Examples:"
    Write-Output "  # Analyze current directory"
    Write-Output "  .\$($MyInvocation.MyCommand.Name) ."
    Write-Output ""
    Write-Output "  # Analyze specific project (positional)"
    Write-Output "  .\$($MyInvocation.MyCommand.Name) C:\path\to\project"
    Write-Output ""
    Write-Output "  # Analyze specific project (named parameter)"
    Write-Output "  .\$($MyInvocation.MyCommand.Name) -Project C:\path\to\project"
    Write-Output ""
    Write-Output "  # Custom output directory"
    Write-Output "  .\$($MyInvocation.MyCommand.Name) C:\path\to\project -Output C:\analysis-results"
    Write-Output ""
    Write-Output "Workflow:"
    Write-Output "  1. Enumerate all files in the project (full recursive scan)"
    Write-Output "  2. Generate file manifest with metadata (JSON)"
    Write-Output "  3. AI agent analyzes manifest and determines:"
    Write-Output "     - Technology stack and framework"
    Write-Output "     - Files to include/exclude (no hardcoded filters)"
    Write-Output "     - File reading strategy (full/sampled/metadata-only)"
    Write-Output "  4. AI agent reads selected files and generates comprehensive analysis"
    Write-Output ""
    Write-Output "Output:"
    Write-Output "  The script prepares an analysis workspace for AI with:"
    Write-Output "  - file-manifest.json    Complete file inventory with metadata"
    Write-Output "  - analysis-report.md    AI-generated comprehensive analysis"
    Write-Output "  - (Additional reports generated by AI as needed)"
    Write-Output ""
    exit 0
}

# Validate project path
if (-not (Test-Path $Project -PathType Container)) {
    Write-Error "ERROR: Project path does not exist or is not a directory: $Project"
    exit 1
}

$Project = (Resolve-Path $Project).Path
$projectName = Split-Path -Leaf $Project

# Validate scope B requirements
if ($Scope -eq "B") {
    if ([string]::IsNullOrEmpty($ConcernType) -or [string]::IsNullOrEmpty($CurrentImpl) -or [string]::IsNullOrEmpty($TargetImpl)) {
        Write-Error "Scope B requires -ConcernType, -CurrentImpl, and -TargetImpl parameters"
        exit 1
    }
}

Write-Host "`n====================================== " -ForegroundColor Blue
Write-Host "AI-Driven Project Analysis" -ForegroundColor Blue
Write-Host "====================================== `n" -ForegroundColor Blue

# Setup output directory
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Setting Up Analysis Workspace" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

if ($Output -eq "") {
    $timestamp = Get-Date -Format "yyyy-MM-dd-HHmmss"
    # Always create .analysis folder at repo root for consistency
    $Output = Join-Path $repoRoot ".analysis\$projectName-$timestamp"
}

New-Item -ItemType Directory -Path $Output -Force | Out-Null
New-Item -ItemType Directory -Path (Join-Path $Output "checkpoints") -Force | Out-Null
Write-Host "[OK] Output directory: $Output" -ForegroundColor Green

# Define output file paths (for AI agent reference)
$analysisReport = Join-Path $Output "analysis-report.md"
$recommendedSpec = Join-Path $Output "recommended-spec.md"
$dependencyAudit = Join-Path $Output "dependency-audit.json"
$metricsSummary = Join-Path $Output "metrics-summary.json"
$decisionMatrix = Join-Path $Output "decision-matrix.md"

Write-Host ""

# Run enumeration
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Enumerating Project Files" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

Write-Host "[INFO] Running full recursive scan..." -ForegroundColor Blue
Write-Host "[INFO] AI will determine which files to analyze based on detected technology" -ForegroundColor Blue

$manifestFile = Join-Path $Output "file-manifest.json"
$enumerateScript = Join-Path $scriptDir "enumerate-project.ps1"

try {
    & $enumerateScript -Project $Project -Output $manifestFile -MaxSize 10485760
    Write-Host "[OK] File manifest generated: $manifestFile" -ForegroundColor Green

    # Display summary
    if (Test-Path $manifestFile) {
        $manifest = Get-Content $manifestFile | ConvertFrom-Json
        $totalFiles = $manifest.statistics.total_files
        $totalSizeMB = [math]::Round($manifest.statistics.total_size_bytes / 1MB, 2)

        Write-Host "[INFO] Total files: $totalFiles" -ForegroundColor Blue
        Write-Host "[INFO] Total size: ${totalSizeMB}MB" -ForegroundColor Blue
    }
}
catch {
    Write-Host "[X] File enumeration failed: $_" -ForegroundColor Red
    exit 1
}

Write-Host ""

# Detect tech stack
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Detecting Technology Stack" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

Write-Host "[INFO] Analyzing indicator files..." -ForegroundColor Blue

$techStackFile = Join-Path $Output "tech-stack.json"
$techStack = @{
    schema_version = "1.0"
    languages = @()
    frameworks = @{ backend = @(); frontend = @() }
    build_tools = @()
    databases = @()
    indicators_found = @()
}

if (Test-Path $manifestFile) {
    $manifest = Get-Content $manifestFile | ConvertFrom-Json

    # Node.js / JavaScript
    if ($manifest.files | Where-Object { $_.path -like "*package.json" }) {
        $techStack.languages += "javascript"
        $techStack.indicators_found += @{ file = "package.json"; type = "nodejs"; confidence = "high" }

        $pkgJsonPath = ($manifest.files | Where-Object { $_.path -like "*package.json" } | Select-Object -First 1).path
        $fullPkgPath = Join-Path $Project $pkgJsonPath
        if (Test-Path $fullPkgPath) {
            $pkgContent = Get-Content $fullPkgPath -Raw
            if ($pkgContent -match '"react":\s*"\^?([0-9.]+)"') {
                $reactVersion = $matches[1]
                $techStack.frameworks.frontend += "react-$reactVersion"
            }
            if ($pkgContent -match '"express"') {
                $techStack.frameworks.backend += "express"
            }
            if ($pkgContent -match '"next"') {
                $techStack.frameworks.frontend += "nextjs"
            }
        }
    }

    # Java / Maven
    if ($manifest.files | Where-Object { $_.path -like "*pom.xml" }) {
        $techStack.languages += "java"
        $techStack.build_tools += "maven"
        $techStack.indicators_found += @{ file = "pom.xml"; type = "java-maven"; confidence = "high" }

        $pomPath = ($manifest.files | Where-Object { $_.path -like "*pom.xml" } | Select-Object -First 1).path
        $fullPomPath = Join-Path $Project $pomPath
        if (Test-Path $fullPomPath) {
            $pomContent = Get-Content $fullPomPath -Raw
            if ($pomContent -match 'spring-boot') {
                $springVersion = "unknown"
                if ($pomContent -match 'spring-boot.*?<version>([^<]+)</version>') {
                    $springVersion = $matches[1]
                }
                $techStack.frameworks.backend += "spring-boot-$springVersion"
            }
        }
    }

    # Java / Gradle
    if ($manifest.files | Where-Object { $_.path -like "*build.gradle*" }) {
        $techStack.languages += "java"
        $techStack.build_tools += "gradle"
        $techStack.indicators_found += @{ file = "build.gradle"; type = "java-gradle"; confidence = "high" }
    }

    # Python
    if ($manifest.files | Where-Object { $_.path -like "*requirements.txt" -or $_.path -like "*setup.py" -or $_.path -like "*pyproject.toml" }) {
        $techStack.languages += "python"
        $techStack.indicators_found += @{ file = "requirements.txt"; type = "python"; confidence = "high" }

        $reqPath = ($manifest.files | Where-Object { $_.path -like "*requirements.txt" } | Select-Object -First 1).path
        if ($reqPath) {
            $fullReqPath = Join-Path $Project $reqPath
            if (Test-Path $fullReqPath) {
                $reqContent = Get-Content $fullReqPath -Raw
                if ($reqContent -match 'django') { $techStack.frameworks.backend += "django" }
                if ($reqContent -match 'flask') { $techStack.frameworks.backend += "flask" }
            }
        }
    }

    # .NET
    if ($manifest.files | Where-Object { $_.path -like "*.csproj" -or $_.path -like "*.sln" }) {
        $techStack.languages += "csharp"
        $techStack.build_tools += "dotnet"
        $techStack.indicators_found += @{ file = "*.csproj"; type = "dotnet"; confidence = "high" }
    }

    # Ruby
    if ($manifest.files | Where-Object { $_.path -like "*Gemfile" }) {
        $techStack.languages += "ruby"
        $techStack.indicators_found += @{ file = "Gemfile"; type = "ruby"; confidence = "high" }
    }

    # Go
    if ($manifest.files | Where-Object { $_.path -like "*go.mod" }) {
        $techStack.languages += "go"
        $techStack.indicators_found += @{ file = "go.mod"; type = "golang"; confidence = "high" }
    }

    # Remove duplicates
    $techStack.languages = $techStack.languages | Select-Object -Unique
    $techStack.frameworks.backend = $techStack.frameworks.backend | Select-Object -Unique
    $techStack.frameworks.frontend = $techStack.frameworks.frontend | Select-Object -Unique
    $techStack.build_tools = $techStack.build_tools | Select-Object -Unique
}

$techStack | ConvertTo-Json -Depth 10 | Out-File -FilePath $techStackFile -Encoding utf8
Write-Host "[OK] Tech stack detected: $techStackFile" -ForegroundColor Green

if ($techStack.languages) {
    $langs = $techStack.languages -join ", "
    Write-Host "[INFO] Languages: $langs" -ForegroundColor Blue
}
if ($techStack.frameworks.backend) {
    $backend = $techStack.frameworks.backend -join ", "
    Write-Host "[INFO] Backend: $backend" -ForegroundColor Blue
}
if ($techStack.frameworks.frontend) {
    $frontend = $techStack.frameworks.frontend -join ", "
    Write-Host "[INFO] Frontend: $frontend" -ForegroundColor Blue
}

Write-Host ""

# Generate file structure
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Analyzing File Structure" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

Write-Host "[INFO] Categorizing files..." -ForegroundColor Blue

$structureFile = Join-Path $Output "file-structure.json"

if (Test-Path $manifestFile) {
    $manifest = Get-Content $manifestFile | ConvertFrom-Json

    $controllers = ($manifest.files | Where-Object { $_.path -match '(controller|route|endpoint)' }).Count
    $services = ($manifest.files | Where-Object { $_.path -match '(service|manager|handler|usecase)' }).Count
    $models = ($manifest.files | Where-Object { $_.path -match '(model|entity|schema|domain)' }).Count
    $repositories = ($manifest.files | Where-Object { $_.path -match '(repository|repo|dao|data)' }).Count
    $configs = ($manifest.files | Where-Object { $_.path -match '(config|settings|properties|yml|yaml|env)' }).Count
    $security = ($manifest.files | Where-Object { $_.path -match '(auth|security|jwt|oauth|permission)' }).Count
    $middleware = ($manifest.files | Where-Object { $_.path -match 'middleware' }).Count
    $utils = ($manifest.files | Where-Object { $_.path -match '(util|helper|common|shared)' }).Count
    $tests = ($manifest.files | Where-Object { $_.path -match '(test|spec|__tests__)' }).Count
    $docs = ($manifest.files | Where-Object { $_.path -match '(README|CHANGELOG|LICENSE|\.md$)' }).Count

    $entryPoints = $manifest.files | Where-Object { $_.path -match '(main\.|index\.|app\.|application\.|server\.|start)' } | Select-Object -ExpandProperty path -First 10

    $structure = @{
        schema_version = "1.0"
        total_files = $manifest.statistics.total_files
        categories = @{
            controllers = $controllers
            services = $services
            models = $models
            repositories = $repositories
            configs = $configs
            security = $security
            middleware = $middleware
            utils = $utils
            tests = $tests
            docs = $docs
        }
        entry_points = @($entryPoints)
        analysis_priority = @{
            critical = @("configs", "security", "entry_points")
            high = @("controllers", "services", "models", "repositories")
            medium = @("middleware", "utils")
            low = @("tests", "docs")
        }
    }

    $structure | ConvertTo-Json -Depth 10 | Out-File -FilePath $structureFile -Encoding utf8
    Write-Host "[OK] File structure generated: $structureFile" -ForegroundColor Green

    $coreFiles = $controllers + $services + $models + $repositories
    Write-Host "[INFO] Core application files: $coreFiles" -ForegroundColor Blue
    Write-Host "[INFO] Configuration files: $configs" -ForegroundColor Blue
    Write-Host "[INFO] Test files: $tests" -ForegroundColor Blue
}

Write-Host ""

# Generate project metadata
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Generating Project Metadata" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

$metadataFile = Join-Path $Output "project-metadata.json"
$timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

$concernDetails = $null
if ($Scope -eq "B") {
    $concernDetails = @{
        type = $ConcernType
        current = $CurrentImpl
        target = $TargetImpl
    }
}

$metadata = @{
    schema_version = "1.0"
    project_path = $Project
    project_name = $projectName
    timestamp = $timestamp
    user_inputs = @{
        analysis_scope = if ($Scope) { $Scope } else { $null }
        additional_context = if ($Context) { $Context } else { $null }
        concern_details = $concernDetails
    }
    workspace = @{
        analysis_dir = $Output
        manifest_path = $manifestFile
        tech_stack_path = $techStackFile
        file_structure_path = $structureFile
    }
}

$metadata | ConvertTo-Json -Depth 10 | Out-File -FilePath $metadataFile -Encoding utf8
Write-Host "[OK] Project metadata generated: $metadataFile" -ForegroundColor Green
Write-Host "[INFO] Project: $projectName" -ForegroundColor Blue
if ($Scope) { Write-Host "[INFO] Scope: $Scope" -ForegroundColor Blue }
if ($Context) { Write-Host "[INFO] Context provided: Yes" -ForegroundColor Blue }

Write-Host ""

# Create state directory
$stateDir = Join-Path $repoRoot ".analysis\.state"
New-Item -ItemType Directory -Path $stateDir -Force | Out-Null

# Generate chain ID (8-character hex)
$chainId = -join ((48..57) + (97..102) | Get-Random -Count 8 | ForEach-Object {[char]$_})

# Create bootstrap state
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Preparing Analysis Workspace" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

$timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$projectName = Split-Path -Leaf $Project

$bootstrapState = @{
    chain_id = $chainId
    start_time = $timestamp
    timestamp = $timestamp
    stage = "bootstrap"
    stages_complete = @()
    project_path = $Project
    project_name = $projectName
    analysis_dir = $Output
    manifest_path = $manifestFile
} | ConvertTo-Json -Depth 10

$bootstrapStateFile = Join-Path $stateDir "00-bootstrap.json"
$bootstrapState | Out-File -FilePath $bootstrapStateFile -Encoding utf8

Write-Host "[OK] Created bootstrap state" -ForegroundColor Green
Write-Host "[INFO] Chain ID: $chainId" -ForegroundColor Blue
Write-Host "[INFO] State file: $bootstrapStateFile" -ForegroundColor Blue
Write-Host ""

# Create analysis workspace template
$analysisTemplate = @"
# Project Analysis Report

**Status**: Pending AI Analysis

**Project**: $projectName
**Analysis Date**: $(Get-Date -Format "yyyy-MM-dd")
**Chain ID**: $chainId

---

## Instructions for AI Agent

This workspace has been prepared for comprehensive project analysis. Please:

1. **Read the file-manifest.json** to understand project structure
2. **Detect technology stack** from indicator files (package.json, *.csproj, etc.)
3. **Generate inclusion/exclusion rules** based on detected technology
   - Example: .NET projects exclude bin/, obj/, packages/
   - Example: Node.js projects exclude node_modules/, dist/, build/
4. **Categorize files by priority**:
   - Critical: package files, entry points, configs
   - Important: main source code
   - Supporting: tests, docs, scripts
5. **Read files based on priority and size**:
   - Full read: <100KB or critical files
   - Sampled: 100KB-1MB (first + last portions)
   - Metadata only: >1MB or binary files
6. **Generate comprehensive analysis** including:
   - Technology stack and versions
   - Project structure and architecture
   - Dependencies and their health
   - Code quality indicators
   - Modernization recommendations
   - Feasibility assessment (inline upgrade vs greenfield rewrite)

---

## Analysis Output

<!-- AI agent will replace this entire file with comprehensive analysis -->

"@

$analysisTemplate | Out-File -FilePath $analysisReport -Encoding utf8

Write-Host "[OK] Created analysis workspace" -ForegroundColor Green
Write-Host "[INFO] Analysis report template: $analysisReport" -ForegroundColor Blue
Write-Host "[INFO] Additional artifacts will be generated by AI:" -ForegroundColor Blue
Write-Host "[INFO]   - $recommendedSpec" -ForegroundColor Blue
Write-Host "[INFO]   - $dependencyAudit" -ForegroundColor Blue
Write-Host "[INFO]   - $metricsSummary" -ForegroundColor Blue
Write-Host "[INFO]   - $decisionMatrix" -ForegroundColor Blue
Write-Host ""

# Show summary
Write-Host "====================================== " -ForegroundColor Blue
Write-Host "Analysis Workspace Ready" -ForegroundColor Blue
Write-Host "====================================== " -ForegroundColor Blue

Write-Host "[OK] Workspace created successfully!" -ForegroundColor Green
Write-Host ""
Write-Host "[INFO] Workspace location: $Output" -ForegroundColor Blue
Write-Host "[INFO] File manifest: $manifestFile" -ForegroundColor Blue
Write-Host ""
Write-Host "[INFO] Next steps:" -ForegroundColor Blue
Write-Host "[INFO] 1. AI agent will analyze the file manifest" -ForegroundColor Blue
Write-Host "[INFO] 2. AI will detect technology and generate filter rules" -ForegroundColor Blue
Write-Host "[INFO] 3. AI will read relevant files and generate comprehensive analysis" -ForegroundColor Blue
Write-Host "[INFO] 4. Results will be saved to analysis-report.md" -ForegroundColor Blue
Write-Host ""
Write-Host "[OK] [AI] Ready for AI analysis!" -ForegroundColor Green
