---
stage: file_analysis
requires: 01-setup-and-scope.json
outputs: analysis_state
version: 2.0.0
---

## ⚠️ MANDATORY: Read Agent Instructions First

**BEFORE PROCEEDING:**

1. Check if `AGENTS.md` exists in repository root, `.specify/memory/`, or `templates/` directory
2. **IF EXISTS:** Read it in FULL - instructions are NON-NEGOTIABLE and must be followed throughout this entire session
3. Follow all AGENTS.md guidelines for the duration of this command execution
4. These instructions override any conflicting default behaviors
5. **DO NOT** forget or ignore these instructions as you work through tasks

**Verification:** After reading AGENTS.md (if it exists), acknowledge with:
   "✓ Read AGENTS.md v[X.X] - Following all guidelines"

**If AGENTS.md does not exist:** Proceed with default behavior.

---

# Stage 2: Deep File Analysis

## Purpose

**CRITICAL STAGE**: This is where most analyses fail due to attention dilution. Perform comprehensive file scanning using the 4-step methodology to extract patterns, identify technical debt, and audit dependencies.

This stage has **dedicated focus** for maximum attention and completion rate.

**Note:** Stage 02-structure.md is obsolete - all structure data is now loaded from JSON files generated by the script in Stage 1.

---

## Previous State

Load state from: `.analysis/.state/01-setup-and-scope.json`

You should have:
- `chain_id` - Analysis chain identifier
- `project_path` - Project being analyzed
- `analysis_dir` - Analysis workspace directory
- `manifest_path` - Path to file-manifest.json
- `tech_stack` - Detected technology stack
- `project_type` - Project classification
- `structure` - Project structure details
- `estimation` - File counts and categories
- `additional_context` - User-provided context (may be null)

**IF `additional_context` is provided (not null)**:
- Keep this context in mind throughout your analysis
- Use it to focus on relevant areas (e.g., if user mentioned "performance issues", pay extra attention to performance patterns)
- Reference it when identifying pain points and recommendations
- Include relevant findings in your analysis that address the user's specific concerns

---

## CRITICAL: 4-Step File Analysis Methodology

This methodology is **MANDATORY**. Follow each phase exactly.

---

## Phase 1: Category Scan (25% of time)

Scan 15-20% of files in EACH category to identify patterns.

### Step 1.1: Categorize Files from Manifest

Read `file-manifest.json` and group files by category:

**Core Application Categories**:
1. **Controllers/Routes** - API endpoints, HTTP handlers
2. **Services/Business Logic** - Core business workflows
3. **Models/Entities** - Data structures, domain models
4. **Repositories/DAOs** - Data access layer
5. **Configurations** - App configs, environment settings
6. **Security/Auth** - Authentication, authorization
7. **Middleware** - Request/response processing
8. **Utilities/Helpers** - Shared utility functions

**Supporting Categories**:
9. **Tests** - Unit, integration, E2E tests
10. **Documentation** - README, docs, comments
11. **CI/CD** - Build scripts, deployment configs
12. **Dependencies** - package.json, pom.xml, requirements.txt

### Step 1.2: Pattern Extraction

For EACH category, scan 15-20% of files and extract:

**Controllers/Routes**:
- HTTP endpoints (method, path)
- Request/response DTOs
- Auth requirements (`@PreAuthorize`, `@Secured`, middleware)
- Error handling patterns
- Validation rules

**Services/Business Logic**:
- Workflows and business rules
- External integrations (APIs, message queues)
- Data transformations
- Transaction boundaries (`@Transactional`, commit/rollback)
- Caching patterns

**Models/Entities**:
- Entity relationships (OneToMany, ManyToMany, etc.)
- Validation constraints (`@NotNull`, `@Size`, etc.)
- Computed properties
- Database mappings (`@Table`, `@Column`)

**Repositories/DAOs**:
- CRUD patterns
- Custom queries (JPA, SQL, NoSQL)
- Query complexity
- Caching strategies
- Transaction handling

**Configurations**:
- Connection strings (anonymize sensitive data)
- API keys/secrets (note presence, don't expose values)
- Environment-specific configs
- Feature flags
- Timeout settings

**Security/Auth**:
- Authentication mechanisms (JWT, OAuth, SAML, Basic, etc.)
- Authorization patterns (RBAC, ABAC, ACL)
- Password hashing (bcrypt, scrypt, argon2)
- Token settings (expiration, refresh)
- CORS policies
- Rate limiting

**Middleware**:
- Request processing (parsing, validation)
- Response transforms
- Logging/monitoring
- Error handling
- Performance optimizations

**Utilities/Helpers**:
- Data transforms
- Validation functions
- Date/time handling
- String manipulation
- Cryptographic operations

**Tests**:
- Test frameworks (JUnit, Mockito, Jest, etc.)
- Coverage areas
- Mocking strategies
- Integration/E2E patterns

### Step 1.3: Progress Reporting

**MANDATORY**: Output progress EVERY 10 files:

```text
[Phase 1 - Category Scan]
✓ 10/120 core files scanned (Controllers)
✓ 20/120 core files scanned (Controllers)
✓ 30/120 core files scanned (Services)
...
```text

**Example output after scanning**:

```text
✓ Scanned src/controllers/UserController.java
  Found: Auth[JWT], API[REST], Validation[Bean Validation]

✓ Scanned src/services/UserService.java
  Found: Business Logic[User Management], DB[JPA Repository], Cache[Redis]
```text

---

## Phase 2: Deep Dive (40% of time)

Focus on HIGH-PRIORITY areas with 60-80% file coverage.

### Step 2.1: Prioritize Areas

**Priority 1**: Authentication/Security files (80% coverage)
- Critical for security assessment
- Must understand auth flows completely

**Priority 2**: Database access layers (80% coverage)
- Understand data models and relationships
- Identify query patterns and performance issues

**Priority 3**: API endpoints (70% coverage)
- Map complete API surface
- Document request/response contracts

**Priority 4**: Core business logic (60% coverage)
- Understand key workflows
- Identify critical business rules

### Step 2.2: Deep Pattern Analysis

For each priority area, extract **detailed** information:

#### Authentication/Security Deep Dive

**Extract**:
- Complete auth flow (registration → login → token → refresh → logout)
- User storage mechanism (database, LDAP, external provider)
- Password requirements and hashing algorithm
- Token generation and validation logic
- Session management
- Permission/role system
- Security vulnerabilities (SQL injection, XSS, CSRF)

**Example output**:

```text
Authentication System Analysis:
- Type: Custom JWT implementation
- User Storage: PostgreSQL (users table)
- Password Hashing: bcrypt (cost factor: 10)
- Token: JWT with HS256, 24h expiration
- Refresh: Refresh tokens stored in Redis (30d TTL)
- Authorization: Role-based (ADMIN, USER, GUEST)
- Security Issues:
  * No rate limiting on /api/auth/login (HIGH risk)
  * JWT secret in application.properties (MEDIUM risk)
  * Missing CSRF protection (MEDIUM risk)
```text

#### Database Deep Dive

**Extract**:
- All entities/models with relationships
- Cardinality (OneToOne, OneToMany, ManyToMany)
- Cascade behaviors
- Orphan removal
- Lazy vs Eager loading
- Native SQL queries (count and complexity)
- N+1 query problems
- Missing indexes
- Database migrations (Flyway, Liquibase, etc.)

**Example output**:

```text
Database Layer Analysis:
- ORM: Hibernate/JPA
- Entities: 12 (User, Order, Product, Category, etc.)
- Relationships:
  * User ↔ Order (OneToMany, cascade ALL)
  * Order ↔ OrderItem (OneToMany, orphanRemoval true)
  * Product ↔ Category (ManyToOne)
- Native Queries: 15 (complexity: MEDIUM)
- Performance Issues:
  * N+1 queries in OrderService.findAll() (HIGH)
  * Missing index on orders.user_id (MEDIUM)
  * Eager loading for Order.items (MEDIUM)
- Migrations: Flyway (23 migration scripts)
```text

#### API Endpoints Deep Dive

**Extract**:
- All endpoints (method, path, purpose)
- Request/response DTOs
- Authentication requirements
- Validation rules
- Rate limiting
- Error responses
- Versioning strategy

**Example output**:

```text
API Surface Analysis:
Total Endpoints: 47

Authentication Endpoints (5):
- POST /api/auth/register - Public, validates email/password
- POST /api/auth/login - Public, returns JWT
- POST /api/auth/refresh - Requires refresh token
- POST /api/auth/logout - Requires JWT
- GET /api/auth/me - Requires JWT, returns user profile

User Endpoints (8):
- GET /api/users - Requires ADMIN role, paginated
- GET /api/users/{id} - Requires JWT, self or ADMIN
- PUT /api/users/{id} - Requires JWT, self or ADMIN
- DELETE /api/users/{id} - Requires ADMIN role
... (continue for all 47 endpoints)

API Issues:
- No versioning strategy
- Inconsistent error responses
- Missing rate limiting
- No API documentation
```text

### Step 2.3: Progress Reporting

**MANDATORY**: Output progress EVERY 10 files:

```text
[Phase 2 - Deep Dive]
✓ 10/45 security files analyzed
✓ 20/45 security files analyzed
✓ Auth flow complete: Custom JWT with bcrypt
✓ 10/25 database files analyzed
...
```text

---

## Phase 3: Configuration Analysis (15% of time)

**MANDATORY**: Analyze ALL configuration files.

### Step 3.1: Configuration Files

Scan and document:

**Application Configs**:
- `application.yml`, `application.properties`
- `appsettings.json`, `web.config`
- `.env` files
- Config classes (`@Configuration`, `@Bean`)

**Build Configs**:
- `pom.xml`, `build.gradle`
- `package.json`
- `*.csproj`, `*.sln`
- `requirements.txt`, `setup.py`

**Infrastructure Configs**:
- `Dockerfile`, `docker-compose.yml`
- Kubernetes manifests
- CI/CD configs (`.github/workflows/`, `.gitlab-ci.yml`, `Jenkinsfile`)
- Cloud configs (AWS, Azure, GCP)

### Step 3.2: Extract Configuration Details

**Database**:
- Connection strings (anonymize credentials)
- Pool size, timeout settings
- Schema/database name

**External Services**:
- API endpoints
- Timeout/retry settings
- Circuit breaker configs

**Performance**:
- Thread pool sizes
- Cache TTL settings
- Connection limits

**Security**:
- CORS settings
- Rate limiting
- Session timeout
- Cookie settings

**Example output**:

```text
Configuration Analysis:

Database:
- Type: PostgreSQL
- Host: localhost:5432
- Database: legacy_app_db
- Pool: min=5, max=20
- Connection timeout: 30s

Redis Cache:
- Host: localhost:6379
- TTL: 1h (user sessions), 5m (API cache)
- Max memory: 256MB

External APIs:
- Payment Gateway: https://api.payment.com
  * Timeout: 10s
  * Retry: 3 attempts, exponential backoff
- Email Service: SendGrid
  * API key: Configured (sg_xxx...)

Security:
- CORS: Allowed origins: http://localhost:3000
- Session: 24h timeout, HTTP-only cookies
- Rate Limit: 100 req/min per IP (not enforced)
```text

---

## Phase 4: Test Coverage (20% of time)

Scan test directories to understand quality assurance.

### Step 4.1: Test Framework Detection

Identify:
- Unit test framework (JUnit, Mockito, Jest, xUnit, pytest, etc.)
- Integration test framework
- E2E test framework (Selenium, Cypress, Playwright)
- Code coverage tool (JaCoCo, Istanbul, Coverage.py)

### Step 4.2: Test Analysis

**Extract**:
- Number of test files
- Test categories (unit, integration, E2E)
- Coverage areas (controllers, services, repositories)
- Mocking strategies
- Test patterns (AAA, Given-When-Then)
- Gaps in coverage

**Example output**:

```text
Test Coverage Analysis:

Frameworks:
- Unit: JUnit 5 + Mockito
- Integration: Spring Test
- E2E: None detected
- Coverage: JaCoCo (62% overall)

Test Count:
- Unit tests: 145 files
- Integration tests: 23 files
- E2E tests: 0 files

Coverage by Layer:
- Controllers: 75% (good)
- Services: 65% (moderate)
- Repositories: 45% (low)
- Security: 30% (critical gap)

Gaps:
- No E2E tests
- Low security test coverage
- Missing integration tests for external APIs
- No performance/load tests
```text

---

## Dependency Audit (Parallel)

Run dependency audit in parallel with file analysis.

### Step 1: Generate Dependency Tree

**Java (Maven)**:

```bash
mvn dependency:tree -DoutputFile=deps.txt
```text

**Java (Gradle)**:

```bash
gradle dependencies > deps.txt
```text

**Node.js**:

```bash
npm audit --json > npm-audit.json
npm list --depth=0 > deps.txt
```text

**.NET**:

```bash
dotnet list package --vulnerable --include-transitive > deps.txt
```text

**Python**:

```bash
pip list --format=json > deps.json
safety check --json > safety-audit.json
```text

### Step 2: Analyze Dependencies

**Extract**:
- Total dependencies (direct + transitive)
- Outdated packages
- Vulnerable packages (with CVEs)
- Deprecated packages
- License issues

**Example output**:

```text
Dependency Audit:

Total: 145 dependencies
- Direct: 23
- Transitive: 122

Outdated: 15 packages
- Spring Boot: 2.3.4 → 2.7.5 (LTS available)
- React: 16.13.1 → 18.2.0 (major upgrade)
- PostgreSQL Driver: 42.2.18 → 42.5.0

Vulnerable: 5 packages (CRITICAL: 1, HIGH: 2, MEDIUM: 2)
- Log4j: 2.14.1 → CRITICAL (CVE-2021-44228 - Log4Shell)
- Spring Security: 5.3.9 → HIGH (CVE-2022-22978)
- Jackson: 2.11.3 → HIGH (CVE-2020-36518)
- Lodash: 4.17.19 → MEDIUM (CVE-2020-8203)
- Axios: 0.19.2 → MEDIUM (CVE-2021-3749)

Deprecated:
- Moment.js (use date-fns or Luxon)
- Request (use axios or node-fetch)
```text

---

## Output: Patterns Found

Generate comprehensive patterns object:

```json
{
  "patterns_found": {
    "authentication": {
      "type": "JWT",
      "implementation": "Custom with bcrypt",
      "locations": [
        "src/security/JwtTokenProvider.java",
        "src/security/SecurityConfig.java",
        "src/controllers/AuthController.java"
      ],
      "complexity": "MEDIUM",
      "issues": [
        "No rate limiting on login endpoint (HIGH)",
        "JWT secret in config file (MEDIUM)"
      ]
    },
    "database": {
      "type": "Relational",
      "engine": "PostgreSQL 12.5",
      "orm": "Hibernate/JPA",
      "entities": 12,
      "relationships": 18,
      "native_queries": 15,
      "issues": [
        "N+1 queries in OrderService (HIGH)",
        "Missing indexes (MEDIUM)",
        "Eager loading overuse (MEDIUM)"
      ]
    },
    "api": {
      "style": "REST",
      "endpoints": 47,
      "versioning": "None",
      "authentication": "JWT Bearer Token",
      "issues": [
        "No versioning strategy (HIGH)",
        "Inconsistent error handling (MEDIUM)",
        "Missing rate limiting (HIGH)"
      ]
    },
    "caching": {
      "detected": true,
      "type": "Redis",
      "version": "6.2",
      "patterns": ["User sessions", "API response cache"],
      "ttl": {
        "sessions": "24h",
        "api_cache": "5m"
      }
    },
    "message_bus": {
      "detected": false
    },
    "observability": {
      "logging": ["SLF4J", "Logback"],
      "monitoring": [],
      "issues": [
        "No structured logging (MEDIUM)",
        "No distributed tracing (MEDIUM)",
        "Missing metrics collection (LOW)"
      ]
    },
    "testing": {
      "frameworks": ["JUnit 5", "Mockito", "Spring Test"],
      "coverage": "62%",
      "gaps": [
        "No E2E tests (HIGH)",
        "Low security test coverage (HIGH)",
        "Missing API integration tests (MEDIUM)"
      ]
    }
  }
}
```text

---

## Output: Files Analyzed Statistics

Track analysis completeness:

```json
{
  "files_analyzed": {
    "total": 187,
    "by_category": {
      "controllers": 15,
      "services": 18,
      "models": 12,
      "repositories": 12,
      "configs": 15,
      "security": 8,
      "middleware": 6,
      "utilities": 14,
      "tests": 68,
      "infrastructure": 12,
      "documentation": 7
    },
    "coverage_percentage": {
      "core_application": 85,
      "supporting": 70,
      "overall": 76
    }
  }
}
```text

---

## Output: Dependencies

```json
{
  "dependencies": {
    "total": 145,
    "direct": 23,
    "transitive": 122,
    "outdated": 15,
    "vulnerable": 5,
    "critical_vulns": [
      "CVE-2021-44228 (Log4j Log4Shell)",
      "CVE-2022-22978 (Spring Security)"
    ],
    "deprecated": [
      "moment.js",
      "request"
    ],
    "license_issues": []
  }
}
```text

---

## Quality Gates

Before completing this stage, verify:

- [ ] **Minimum 70% of important files analyzed**
  - If < 70%, return to Phase 2 for more coverage

- [ ] **All configuration files analyzed**
  - If incomplete, complete Phase 3

- [ ] **Pattern extraction complete**
  - At least 50 feature descriptions with file:line references
  - At least 20 technical debt items
  - At least 10 security findings

- [ ] **Dependency audit complete**
  - All vulnerable packages identified
  - Outdated packages listed
  - Critical CVEs flagged

- [ ] **Progress reported throughout**
  - Progress updates shown every 10 files
  - Current phase clearly indicated

---

## Output State

Merge with previous state and add file analysis data:

```json
{
  ...previous_state,
  "stage": "file_analysis",
  "timestamp": "2025-11-14T10:45:00Z",
  "stages_complete": ["initialization", "scope_definition", "structure_analysis", "file_analysis"],
  "files_analyzed": 187,
  "patterns_found": { /* patterns object */ },
  "dependencies": { /* dependencies object */ },
  "analysis_quality": {
    "core_coverage": 85,
    "features_extracted": 127,
    "tech_debt_items": 34,
    "security_findings": 18
  }
}
```text

---

## Completion Marker

When file analysis is complete and quality gates pass, output:

```text
STAGE_COMPLETE:FILE_ANALYSIS
STATE_PATH: .analysis/.state/02-file-analysis.json
```

Save the state JSON to `.analysis/.state/02-file-analysis.json`.

---

## Error Handling

**If file reading fails**:
- Log the error
- Continue with remaining files
- Note gaps in final report

**If quality gate fails**:
- Output: "⚠️ Quality gate failed: {reason}"
- Return to relevant phase
- Do NOT proceed until gate passes

**If dependency audit fails**:
- Output: "⚠️ Dependency audit failed: {error}"
- Mark dependencies as "unknown"
- Continue with file analysis

---

## Example Execution

```text
=== Stage 2: Deep File Analysis ===

Previous state loaded from: .analysis/.state/01-setup-and-scope.json
Chain ID: a3f7c8d1

Starting comprehensive file analysis...

[Phase 1 - Category Scan]
Categorizing files from manifest...
✓ Categorized 245 files into 11 categories

Scanning controllers...
✓ 3/15 controllers scanned
✓ 6/15 controllers scanned
✓ Found: REST API with JWT auth, 47 endpoints

Scanning services...
✓ 4/18 services scanned
✓ 8/18 services scanned
✓ Found: Business logic with transaction management

Scanning models...
✓ 3/12 models scanned
✓ Found: JPA entities with relationships

[Phase 2 - Deep Dive]
Deep diving into authentication...
✓ 2/8 security files analyzed
✓ 4/8 security files analyzed
✓ 8/8 security files analyzed
✓ Complete auth flow documented: Custom JWT with bcrypt

Deep diving into database layer...
✓ 3/12 repository files analyzed
✓ 6/12 repository files analyzed
✓ 12/12 repository files analyzed
✓ Found: 12 entities, 18 relationships, N+1 query issues

Deep diving into API layer...
✓ 5/15 controller files analyzed
✓ 10/15 controller files analyzed
✓ 15/15 controller files analyzed
✓ Mapped: 47 endpoints, no versioning, auth issues

[Phase 3 - Configuration Analysis]
Analyzing all configuration files...
✓ Application configs: application.yml, SecurityConfig.java
✓ Build configs: pom.xml, package.json
✓ Infrastructure: Dockerfile, docker-compose.yml
✓ CI/CD: .github/workflows/ci.yml

[Phase 4 - Test Coverage]
Analyzing test suite...
✓ Unit tests: 145 files (62% coverage)
✓ Integration tests: 23 files
✓ E2E tests: None detected
✓ Gaps identified: Security testing, E2E coverage

[Dependency Audit]
Running dependency audit...
✓ Total dependencies: 145 (23 direct, 122 transitive)
✓ Outdated: 15 packages
✓ Vulnerable: 5 packages (2 CRITICAL)
✓ Critical CVEs: CVE-2021-44228 (Log4Shell), CVE-2022-22978

Verifying quality gates...
✓ Coverage: 85% of core files analyzed
✓ Features: 127 extracted with file:line references
✓ Tech debt: 34 items categorized
✓ Security: 18 findings documented
✓ All quality gates passed

STAGE_COMPLETE:FILE_ANALYSIS
STATE_PATH: .analysis/.state/02-file-analysis.json

Next stage: Branching based on analysis_scope
  - If scope = A: 03a-full-app.md
  - If scope = B: 03b-cross-cutting.md
```

---

## State Schema Reference

This stage must produce a state object conforming to `00-state-schema.json`.

Required new fields:
- `files_analyzed` (integer or object)
- `patterns_found` (object)
- `dependencies` (object)

---

## Next Stage

After successful completion, proceed to **DYNAMIC BRANCH**:

- **IF** `analysis_scope = "A"`: **Stage 3A: 03a-full-app.md** (Full Application Analysis)
- **IF** `analysis_scope = "B"`: **Stage 3B: 03b-cross-cutting.md** (Cross-Cutting Concern Analysis)

The master orchestration prompt will load the appropriate branch.
